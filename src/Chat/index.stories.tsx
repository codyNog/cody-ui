import type { Meta, StoryObj } from "@storybook/react";
import { expect } from "@storybook/test";
import { type MouseEvent, useRef, useState } from "react"; // useRefã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
import {
  Popover,
  Menu as RACMenu,
  MenuItem as RACMenuItem,
} from "react-aria-components"; // Popoverã¨RACMenu, RACMenuItemã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
import { Chat } from "."; // Chatã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
// import { Menu } from "../Menu"; // æœªä½¿ç”¨ãªã®ã§å‰Šé™¤
import { getCanvas } from "../libs/storybook";

const meta: Meta<typeof Chat.Root> = {
  // Chat.Rootã‚’åŸºæº–ã«ã™ã‚‹ã‹ã€Chatå…¨ä½“ã‹
  component: Chat.Root, // ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯Chat.Rootã«ã™ã‚‹
  parameters: {
    layout: "fullscreen", // ãƒãƒ£ãƒƒãƒˆUIã¯å…¨ç”»é¢è¡¨ç¤ºãŒã„ã„ã‹ã‚‚
  },
  tags: ["autodocs"], // autogenerated docs
};

export default meta;

type Story = StoryObj<typeof meta>;

// --- Default Story ---
const DefaultChatStory = (args: Story["args"]) => {
  const [messages, setMessages] = useState<
    Array<{
      id: string;
      type: "message" | "typing";
      content?: string;
      isSender?: boolean;
      timestamp?: string;
      description?: string;
    }>
  >([
    {
      id: "1",
      type: "message",
      content: "ã­ãˆã€ä»Šæ—¥ã®ãƒ©ãƒ³ãƒã©ã†ã™ã‚‹ï¼Ÿ",
      isSender: false,
      timestamp: "10:00 AM",
    },
    {
      id: "typing-receiver", // å—ä¿¡è€…ã®ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼
      type: "typing",
      isSender: false,
    },
    {
      id: "2",
      type: "message",
      content: "ãƒ©ãƒ¼ãƒ¡ãƒ³é£Ÿã¹ãŸã„æ°—åˆ†ï¼ğŸœ",
      isSender: true,
      timestamp: "10:01 AM",
    },
    {
      id: "3",
      type: "message",
      content: "ã„ã„ã­ï¼ã©ã“ã®ãƒ©ãƒ¼ãƒ¡ãƒ³å±‹è¡Œãï¼Ÿ",
      isSender: false,
      timestamp: "10:01 AM",
    },
    {
      id: "typing-sender", // é€ä¿¡è€…ã®ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ (ãƒ‡ãƒ¢ç”¨)
      type: "typing",
      isSender: true,
    },
    {
      id: "4",
      type: "message",
      content: "é§…å‰ã®æ–°ã—ã„ã¨ã“æ°—ã«ãªã‚‹ã‚“ã ã‚ˆã­ï½ï¼",
      isSender: true,
      timestamp: "10:02 AM",
      description: "ï¼ˆæœªèª­ï¼‰",
    },
  ]);

  const [menuState, setMenuState] = useState<{
    open: boolean;
    anchorPosition: { top: number; left: number } | null;
    messageId: string | null;
  }>({
    open: false,
    anchorPosition: null,
    messageId: null,
  });

  const triggerRef = useRef<HTMLDivElement>(null); // ãƒ€ãƒŸãƒ¼ã®ãƒˆãƒªã‚¬ãƒ¼è¦ç´ ã®ref

  const handleSend = (newMessageText: string) => {
    const newMessage = {
      id: String(messages.length + 1),
      type: "message" as const,
      content: newMessageText,
      isSender: true,
      timestamp: new Date().toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit",
      }),
    };
    setMessages((prevMessages) => [...prevMessages, newMessage]);
  };

  const handleMessageContextMenu = (
    event: MouseEvent<HTMLDivElement>, // å‹ã‚’æ˜ç¤º
    messageId: string,
  ) => {
    event.preventDefault();
    // console.log("Message context menu triggered:", messageId, event);
    setMenuState({
      open: true,
      anchorPosition: { top: event.clientY, left: event.clientX },
      messageId,
    });
  };

  const handleMessageLongPress = (messageId: string) => {
    // console.log("Message long press triggered:", messageId);
    // é•·æŠ¼ã—æ™‚ã®Menuè¡¨ç¤ºä½ç½®ã€‚ContextMenuã¨åŒã˜ä½ç½®ã«ã™ã‚‹ã€‚
    setMenuState((prevState) => ({
      open: true,
      anchorPosition: prevState.anchorPosition, // ContextMenuã®ä½ç½®ã‚’å†åˆ©ç”¨
      messageId,
    }));
  };

  const handleCloseMenu = () => {
    setMenuState({ open: false, anchorPosition: null, messageId: null });
  };

  const handleEditMessage = (messageId: string | null) => {
    if (messageId) {
      alert(`Edit message: ${messageId}`);
      handleCloseMenu();
    }
  };

  const handleDeleteMessage = (messageId: string | null) => {
    if (messageId) {
      setMessages((prevMessages) =>
        prevMessages.filter((msg) => msg.id !== messageId),
      );
      handleCloseMenu();
    }
  };

  return (
    <>
      <Chat.Root
        {...args}
        style={{
          height: "600px",
          maxWidth: "400px",
          margin: "auto",
          border: "1px solid #ccc",
        }}
      >
        <div
          style={{
            flexGrow: 1,
            overflowY: "auto",
            padding: "16px",
            display: "flex",
            flexDirection: "column",
            gap: "8px",
          }}
        >
          {messages.map((msg) => {
            if (msg.type === "typing") {
              return (
                <Chat.TypingIndicator key={msg.id} isSender={msg.isSender} />
              );
            }
            return (
              <Chat.Message
                key={msg.id}
                isSender={msg.isSender}
                timestamp={msg.timestamp}
                description={msg.description}
                onContextMenu={(event) =>
                  handleMessageContextMenu(event, msg.id)
                }
                onLongPress={() => handleMessageLongPress(msg.id)}
              >
                {msg.content}
              </Chat.Message>
            );
          })}
        </div>
        <Chat.InputArea onSend={handleSend} placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›..." />
      </Chat.Root>
      {/* ãƒ€ãƒŸãƒ¼ã®ãƒˆãƒªã‚¬ãƒ¼è¦ç´  (ç”»é¢å¤–ã«é…ç½®) */}
      <div
        ref={triggerRef}
        style={{ position: "fixed", top: "-9999px", left: "-9999px" }}
      />
      {menuState.open && menuState.anchorPosition && (
        <Popover
          triggerRef={triggerRef} // ãƒ€ãƒŸãƒ¼ã®ãƒˆãƒªã‚¬ãƒ¼refã‚’æ¸¡ã™
          isOpen={menuState.open}
          onOpenChange={(isOpen) => {
            if (!isOpen) handleCloseMenu();
          }}
          // placement="bottom start" // ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ãŸã¾ã¾
          offset={5}
          style={{
            // Popoverã®ä½ç½®ã¯å¼•ãç¶šãstyleã§åˆ¶å¾¡
            position: "fixed",
            top: menuState.anchorPosition.top,
            left: menuState.anchorPosition.left,
          }}
        >
          <RACMenu
            onAction={(key) => {
              if (key === "edit") {
                handleEditMessage(menuState.messageId);
              } else if (key === "delete") {
                handleDeleteMessage(menuState.messageId);
              }
              handleCloseMenu(); // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾Œã‚‚ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‰ã˜ã‚‹
            }}
            aria-label="Message Actions"
            style={{
              background: "var(--md-sys-color-surface-container-high, #FFFFFF)", // ãƒ†ãƒ¼ãƒã‚«ãƒ©ãƒ¼ã‚’ä½¿ã†ã¨ã‚ˆã‚ŠGood
              border: "1px solid var(--md-sys-color-outline-variant, #CAC4D0)",
              borderRadius: "var(--md-sys-shape-corner-extra-small, 4px)",
              padding: "8px 0", // M3 Menu padding
              minWidth: "112px", // M3 Menu min width
              listStyle: "none",
              boxShadow:
                "var(--md-sys-elevation-level2, 0px 3px 8px rgba(0,0,0,0.24))", // M3 Elevation
            }}
          >
            <RACMenuItem
              id="edit"
              style={{
                padding: "0 12px", // M3 MenuItem padding
                height: "48px", // M3 MenuItem height
                display: "flex",
                alignItems: "center",
                cursor: "pointer",
                color: "var(--md-sys-color-on-surface, #1C1B1F)",
              }}
              className="hover:bg-[var(--md-sys-color-surface-container-highest-hover,rgba(0,0,0,0.08))]" // ãƒ›ãƒãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ä¾‹ (ãƒ†ãƒ¼ãƒå¯¾å¿œ)
            >
              ç·¨é›†
            </RACMenuItem>
            <RACMenuItem
              id="delete"
              style={{
                padding: "0 12px",
                height: "48px",
                display: "flex",
                alignItems: "center",
                cursor: "pointer",
                color: "var(--md-sys-color-on-surface, #1C1B1F)",
              }}
              className="hover:bg-[var(--md-sys-color-surface-container-highest-hover,rgba(0,0,0,0.08))]"
            >
              å‰Šé™¤
            </RACMenuItem>
          </RACMenu>
        </Popover>
      )}
    </>
  );
};

export const Default: Story = {
  render: DefaultChatStory,
  args: {},
};

// --- Empty State Story ---
export const Empty: Story = {
  render: (args) => {
    const handleSend = (messageText: string) => {
      alert(`Message sent: ${messageText}`);
    };
    return (
      <Chat.Root
        {...args}
        style={{
          height: "300px",
          maxWidth: "400px",
          margin: "auto",
          border: "1px solid #ccc",
        }}
      >
        <div
          style={{
            flexGrow: 1,
            overflowY: "auto",
            padding: "16px",
            display: "flex",
            flexDirection: "column",
            gap: "8px",
          }}
        >
          {/* No messages */}
        </div>
        <Chat.InputArea
          onSend={handleSend}
          placeholder="æœ€åˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚ã†ï¼"
        />
      </Chat.Root>
    );
  },
  args: {},
};

// --- With Accessories Story ---
const WithAccessoriesChatStory = (args: Story["args"]) => {
  const [messages, setMessages] = useState<
    Array<{ id: string; content: string; isSender?: boolean }>
  >([
    { id: "1", content: "ãƒ•ã‚¡ã‚¤ãƒ«é€ã‚Œã‚‹ï¼Ÿ", isSender: false },
    { id: "2", content: "è©¦ã—ã¦ã¿ã‚‹ã­ï¼", isSender: true },
  ]);

  const handleSend = (newMessageText: string) => {
    setMessages((prevMessages) => [
      ...prevMessages,
      {
        id: String(messages.length + 1),
        content: newMessageText,
        isSender: true,
      },
    ]);
  };

  return (
    <Chat.Root
      {...args}
      style={{
        height: "500px",
        maxWidth: "400px",
        margin: "auto",
        border: "1px solid #ccc",
      }}
    >
      <div
        style={{
          flexGrow: 1,
          overflowY: "auto",
          padding: "16px",
          display: "flex",
          flexDirection: "column",
          gap: "8px",
        }}
      >
        {messages.map((msg) => (
          <Chat.Message key={msg.id} isSender={msg.isSender}>
            {msg.content}
          </Chat.Message>
        ))}
      </div>
      <Chat.InputArea
        onSend={handleSend}
        placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›..."
        leadingAccessory={
          <button type="button" onClick={() => alert("Attach file clicked!")}>
            ğŸ“
          </button>
        }
        trailingAccessory={
          <button type="button" onClick={() => alert("Emoji clicked!")}>
            ğŸ˜€
          </button>
        }
        sendButtonContent="ğŸš€"
      />
    </Chat.Root>
  );
};
export const WithAccessories: Story = {
  render: WithAccessoriesChatStory,
  args: {},
};

// --- Behavior Test (Optional, if needed) ---
export const Behavior: Story = {
  render: DefaultChatStory, // Defaultã®ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ã‚’å†åˆ©ç”¨
  args: {},
  play: async ({ canvasElement }) => {
    const canvas = getCanvas(canvasElement);
    // Chat.InputAreaã®inputè¦ç´ ã‚’å–å¾—
    const inputElement = canvas.getByPlaceholderText("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›...");
    expect(inputElement).toBeTruthy();

    // Chat.InputAreaã®buttonè¦ç´ ã‚’å–å¾— (sendButtonContentãŒ"Send"ã®å ´åˆ)
    // ã‚‚ã—sendButtonContentãŒã‚¢ã‚¤ã‚³ãƒ³ãªã‚‰ã€getByRoleãªã©ã§é©åˆ‡ã«å–å¾—ã™ã‚‹
    // const sendButton = canvas.getByRole('button', { name: /Send/i });
    // expect(sendButton).toBeTruthy();

    // TODO: ã‚ˆã‚Šå…·ä½“çš„ãªã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆã‚’è¿½åŠ 
    // ä¾‹: inputã«å…¥åŠ›ã—ã¦é€ä¿¡ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã€æ–°ã—ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª
  },
};
